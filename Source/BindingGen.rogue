class BindingGen
  PROPERTIES
    source_files    = File[]
    rules_file      : File
    roguec_flags    = ""
    types           = @{}

    old_bindings    : String
    output_library   : String
    api_writer      = String()
    bindings_writer = String()
    class_writer    = String()

  METHODS
    method init( rules_file )

    method add_source( file:File )
      source_files.add( file )

    method generate( bindings_file:File )
      File("Build").create_folder
      local api_file = File( "Build/NativeAPI.json" )

      local cmd = "roguec --output=$"(api_file.esc)
      cmd .= appending( roguec_flags )
      cmd .= appending( source_files.first.esc )

      cmd .= appending( "--doc" )
      forEach (source_file in source_files)
        cmd .= appending( "--doc=$"(source_file.esc) )
      endForEach

      execute cmd

      local api = JSON.load( api_file )
      forEach (mod in api//libraries)
        forEach (type in mod//types)
          if (type//scoped_name.contains('$')) nextIteration
          types[type//scoped_name] = type
        endForEach
      endForEach

      old_bindings = which{ bindings_file.exists:String( bindings_file ) || "" }

      bindings_writer.println ...
      @|library RogueScript
       |
       |class NativeBindings [singleton]
       |  METHODS
       |    method register( vm:VM )
      bindings_writer.indent += 6

      forEach (line in LineReader(rules_file))
        line .= trimmed
        if (line.begins_with('#')) nextIteration

        if (line.begins_with("+=") or line.begins_with("=+"))
          keep_type( line.unleft(2), &extensible )
        elseIf (line.begins_with('='))
          keep_type( line.unleft(1) )
        elseIf (line.begins_with('+'))
          keep_type( line.unleft(1), &extensible, &keep_subclasses )
        else
          keep_type( line, &keep_subclasses )
        endIf
      endForEach

      bindings_writer.indent -= 6
      bindings_writer.println "endClass"
      bindings_writer.println

      local new_bindings = "$\n$$"(api_writer,bindings_writer,class_writer)
      if (new_bindings != old_bindings)
        println "Writing $"(bindings_file)
      else
        println "$ is up-to-date"(bindings_file)
      endIf
      bindings_file.save( new_bindings )  # need to resave regardless for a timestamp build dependency

    method generate( type:Variant, &extensible )
      local first_line = ''vm.register_native_type( <<$>>''(type//scoped_name)
      if (not old_bindings.contains(first_line))
        println "Generating registration for " + type//scoped_name
      endIf

      bindings_writer.print   first_line
      contingent
        sufficient (has_attribute(type,"primitive"))
        sufficient (has_attribute(type,"compound"))
        sufficient (type_name//scoped_name == "Rogue::String")
        bindings_writer.println " )"
        escapeContingent

      satisfied
        bindings_writer.println ','
        bindings_writer.println ''  NativeTypeInfo(''
        bindings_writer.indent += 4

        if (has_attribute(type, "primitive"))
          bindings_writer.println "&instance_of = (value) => value.is_$,"(type//name->String.to_lowercase)
          bindings_writer.println "&variant_type = Variant.TYPE_$,"(type//name->String.to_uppercase)
          bindings_writer.println "&attributes = Attribute.PRIMITIVE"
        elseIf (has_attribute(type, "compound"))
          println "TODO NativeTypeInfo for compound " + type//scoped_name
          which (type//scoped_name)
            case "Rogue::Byte"
              #bindings_writer.println
          endWhich
        elseIf (has_attribute(type, "class"))
          which (type//scoped_name)
            case "Rogue::String"
              bindings_writer.println "&variant_type = Variant.TYPE_STRING"
          endWhich
        endIf

        bindings_writer.indent -= 4
        bindings_writer.println ''  )''
        bindings_writer.println '')''
      endContingent

      which (type//scoped_name)
        case "Rogue::Byte"
          bindings_writer.println ''vm.register_definition( "Rogue::Byte.MAXIMUM", Byte.MAXIMUM->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Byte.MINIMUM", Byte.MINIMUM->String )''
        case "Rogue::Int"
          bindings_writer.println ''vm.register_definition( "Rogue::Int.BITS",    Int.BITS->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int.MAXIMUM", Int.MAXIMUM->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int.MINIMUM", Int.MINIMUM->String )''
        case "Rogue::Int32"
          bindings_writer.println ''vm.register_definition( "Rogue::Int32.MAXIMUM", Int32.MAXIMUM->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int32.MINIMUM", Int32.MINIMUM->String )''
        case "Rogue::Int64"
          bindings_writer.println ''vm.register_definition( "Rogue::Int64.MAXIMUM", Int64.MAXIMUM->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int64.MINIMUM", Int64.MINIMUM->String )''
        case "Rogue::Real"
          bindings_writer.println ''vm.register_definition( "Rogue::Real.BITS",   Real.BITS->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int.MAXIMUM", Int.MAXIMUM->String )''
          bindings_writer.println ''vm.register_definition( "Rogue::Int.MINIMUM", Int.MINIMUM->String )''
      endWhich

      forEach (m in type//methods)
        forEach (param at i in m//parameters)
          if (param//default_parameter)
            bindings_writer.print   ''vm.register_native_method_default_arg( ''
            bindings_writer.print   ''"$", "$", $, ''(type//scoped_name,m//signature,i+1)
            if (param//default_value == '""')
              bindings_writer.println @|'""' )
            else
              bindings_writer.println ''"$" )''(param//default_value->String.to_escaped_ascii(''"''))
            endIf
          endIf
        endForEach
      endForEach

      if (extensible)
        bindings_writer.println ''vm.register_extensible_type( "$", (rs_type)=>$::RogueScript$(rs_type) )''...
          (type//scoped_name,type["library"],type//name)

        forEach (m in type//methods)
          if (m//type_context != type//scoped_name) nextIteration
          if (type//base_class)
            local base_class = types[type//base_class]
            if (base_class//extensible and base_class//methods_by_signature[m//signature]) nextIteration
          endIf

          bindings_writer.println ''vm.register_native_method_slot( "$", $, "$" )'' ...
            (type//scoped_name, m//index, m//signature)
        endForEach
      endIf
      bindings_writer.println

      if (not extensible) return

      local scoped_name = "$::RogueScript$" (type["library"],type//name)
      if (not old_bindings.contains(scoped_name))
        println "Generating extensible class " + scoped_name
      endIf

      if (type["library"] != output_library)
        output_library = type["library"]
        class_writer.println "library " + output_library
        class_writer.println
      endIf

      if (type//scoped_name == "RogueScript::RogueScriptObject")
        class_writer.println "augment RogueScriptObject"
      else
        class_writer.println "class RogueScript$ : $, RogueScript::RogueScriptAdapted [api]"(type//name,type//name)
      endIf
      class_writer.println "  METHODS"
      class_writer.indent += 4

      forEach (m at i in type//methods)
        if (m//type_context != type//scoped_name) nextIteration
        if (type//base_class)
          local base_class = types[type//base_class]
          if (base_class//extensible and base_class//methods_by_signature[m//signature]) nextIteration
        endIf

        class_writer.print "method "
        class_writer.print m//name
        class_writer.print '('
        if (m//parameters.count)
          class_writer.print ' '
          forEach (param at i in m//parameters)
            if (i > 0) class_writer.print ", "
            class_writer.print param//name
              if (param//default_value)
                class_writer.print '='
                class_writer.print param//default_value
              endIf
              class_writer.print ':'
              class_writer.print param//type
          endForEach
          class_writer.print ' '
        endIf
        class_writer.print ')'
        if (m//return_type)
          class_writer.print "->"
          class_writer.print m//return_type
        endIf
        class_writer.println " [override]"
        class_writer.println "  if local m = rs_type.native_method_overrides[$]"(i)
        class_writer.print   "    "
        if (m//return_type)
          class_writer.print "return "
        endIf
        class_writer.print "m( this"
        forEach (param in m//parameters)
          class_writer.print ", "
          class_writer.print param//name
        endForEach
        class_writer.println " )"
        class_writer.println "  else"
        class_writer.print   "    "
        if (m//return_type)
          class_writer.print "return "
        endIf
        class_writer.print   "prior."
        class_writer.print   m//name
        class_writer.print   '('
        if (m//parameters.count)
          class_writer.print   ' '
          forEach (param at param_i in m//parameters)
            if (param_i) class_writer.print ", "
            class_writer.print param//name
          endForEach
          class_writer.print   ' '
        endIf
        class_writer.println ')'
        class_writer.println "  endIf"
        class_writer.println
      endForEach

      class_writer.indent -= 4
      if (type//scoped_name == "RogueScript::RogueScriptObject")
        class_writer.println "endAugment"
      else
        class_writer.println "endClass"
      endIf
      class_writer.println

    method has_attribute( type:Variant, attribute:String )->Logical
      if (not type//attributes) return false
      return type//attributes.contains( attribute )

    method instance_of( extended_type:Variant, base_type:Variant )->Logical
      if (not extended_type) return false

      if (extended_type//scoped_name == base_type//scoped_name) return true

      if (extended_type//base_class)
        if (instance_of(types[extended_type//base_class],base_type)) return true
      endIf

      if (extended_type//aspects)
        forEach (aspect_type in extended_type//aspects)
          if (instance_of(types[aspect_type],base_type)) return true
        endForEach
      endIf

      return false

    method keep_type( type_name:String, &extensible, &keep_subclasses )
      local type = types[type_name]
      if (not type)
        throw Error( "Unknown type: " + type_name )
      endIf

      if (type//name->String.begins_with("RogueScript")) return

      if (type//kept) return
      type//kept = true
      if (extensible) type//extensible = true

      api_writer.println "$api " + type_name

      type//methods_by_signature = @{}
      forEach (m at i in rewriter=type//methods.as_list.rewriter)
        local sig = m//signature
        contingent
          necessary (sig != "hash_code()")
          necessary (sig != "library_name()")
          necessary (sig != "type_id()")
          necessary (sig != "type_name()")
          necessary (sig != "type_info()")
          necessary (sig != "type_info_index()")
          rewriter.write( m )
          type//methods_by_signature[m//signature] = m
        endContingent
      endForEach

      local next_method_index = 0
      if (type//base_class)
        keep_type( type//base_class, &=extensible )

        local base_class = types[type//base_class]
        next_method_index = base_class//methods.count

        forEach (base_m in base_class//methods)
          local override_m = type//methods_by_signature[base_m//signature]
          if (override_m)
            override_m//index = base_m//index
            override_m//type_context = type_name
          else
            type//methods.add( base_m )
            type//methods_by_signature[base_m//signature] = base_m
          endIf
        endForEach
      endIf

      forEach (m at i in type//methods)
        if (not m//type_context)
          m//type_context = type_name
          m//index = next_method_index
          ++next_method_index
        endIf
      endForEach

      type//methods.sort( $1//index < $2//index )

      generate( type, &=extensible )

      if (keep_subclasses)
        forEach (other_type in types)
          if (instance_of(other_type,type)) keep_type( other_type//scoped_name, &=extensible )
        endForEach
      endIf

endClass

library RogueScript

class Library
  GLOBAL METHODS
    method create( t:Token, name:String )->Library
      local mod = Program.libraries[ name ]
      if (mod) return mod

      mod = Library( t, name, &initializer )
      Program.libraries[ name ] = mod
      return mod

  PROPERTIES
    t                 : Token
    name              : String

    global_statements : Statements
    m_on_launch       : GlobalMethod

    used_libraries      = [String:Library]
    types             = [String:Type]

    visiting          : Logical

  METHODS
    method init( t, name, initializer:Logical )
      Program.libraries[name] = this
      use_library( t, "Rogue" )

    method define_type( def:Class )->Type
      return define_type( def.t, def.name->String, def.attributes.cloned ).[ t=t, definition=def ]

    method define_type( t:Token, type_name:String, attributes:Attributes )->Type
      local type = types[type_name]

      if (type)
        if (type.definition)
          throw t.error( "Type $::$ is already defined."(name,type_name) )
        endIf
        type.attributes.flags |= attributes.flags
        type.attributes.add( forEach in attributes )
      else
        type = Type( t, this, type_name, attributes )
        types[type_name] = type
        Program.types[type.scoped_name] = type
      endIf

      if (this is Program.default_library)
        if (type.attributes.is_primitive)
          which (type_name)
            case "Byte":      type.variant_type = Variant.TYPE_BYTE
            case "Character": type.variant_type = Variant.TYPE_CHARACTER
            case "Int":       type.variant_type = Variant.TYPE_INT
            case "Int32":     type.variant_type = Variant.TYPE_INT32
            case "Int64":     type.variant_type = Variant.TYPE_INT64
            case "Real":      type.variant_type = Variant.TYPE_REAL
            case "Real32":    type.variant_type = Variant.TYPE_REAL32
            case "Real64":    type.variant_type = Variant.TYPE_REAL64
            case "Logical":   type.variant_type = Variant.TYPE_LOGICAL
          endWhich
        endIf
      endIf

      return type

    method define_type( t:Token, type_name:String, attributes:Int )->Type
      return define_type( t, type_name, Attributes(t,attributes) )

    method find_type( type_name:String, &limited )->Type
      if (visiting) return null

      if (type_name.contains("::"))
        # Name is qualified with library name
        return Program.types[type_name]
      endIf

      local result = types[type_name]
      if (result) return result

      if (limited) return null

      temporarily visiting = true
        forEach (mod in used_libraries)
          result = mod.find_type( type_name )
          if (result) return result
        endForEach
        return null
      endTemporarily

    method launch
      if (m_on_launch)
        VM.stack.add( Variant() )
        Program.execute( m_on_launch )
      endIf

    method must_find_type( t:Token, type_name:String, &limited )->Type
      local result = find_type( type_name, &=limited )
      if (result) return result
      throw t.error( "Reference to undefined type $."(type_name) )

    method must_find_type( type:Type )->Type
      if (type.module_context and type.module_context is not this)
        return type.module_context.must_find_type( type )
      else
        return must_find_type( type.t, type.name )
      endIf

    method organize
      if (global_statements)
        if (m_on_launch)
          m_on_launch.statements.add( forEach in global_statements )
        else
          m_on_launch = GlobalMethod( t, "on_launch", &statements=global_statements )
          type( t, "Routine" ).add_global_method( m_on_launch )
        endIf
        global_statements = null
      endIf

    method to->String
      return name

    method type( t:Token, name:String, attributes=Attribute.OBJECT:Int )->Type
      if (name.contains("::"))
        return Program.get_library( t, name.before_last("::") ).type( t, name.after_last("::"), &=attributes )
      endIf

      local result = types[name]
      if (result) return result

      return define_type( t, name, attributes )

    method type_Routine->Type
      return type( t, "Routine" )

    method use_library( t:Token, name:String )
      if (name == this.name) return
      if (used_libraries.contains(name)) return

      local mod = Program.libraries[name]
      if (not mod)
        mod = Library( t, name )
      endIf
      used_libraries[ name ] = mod

    method validate_type( type:Type )->Type
      if (not type or type.module_context) return type
      return must_find_type( type.t, type.name )
endClass

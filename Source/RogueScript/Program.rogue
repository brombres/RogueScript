library RogueScript

class Program [singleton]
  PROPERTIES
    t              : Token
    default_library : Library
    current_library : Library
    libraries        = [String:Library]
    types          = [String:Type]  # All types, keys fully qualified e.g. RogueScript::Int
    definitions    = [String:Cmd]   # Includes VM.definitions

    type_Byte      : Type
    type_Character : Type
    type_Int       : Type
    type_Int32     : Type
    type_Int64     : Type
    type_Logical   : Type
    type_Real      : Type
    type_Real32    : Type
    type_Real64    : Type
    type_XY        : Type
    type_String    : Type
    type_Object    : Type
    type_RogueScriptObject : Type

    pending_elements = ProgramElements[]

    parser = Parser()

  METHODS
    method init
      .configure

    method init( elements:ProgramElements[] )
      .configure
      add( elements )

    method add( elements:ProgramElements[] )
      pending_elements.add( elements )

    method add_definition( name:String, value:String )
      parser.reset( "[define $]"(name), value )
      definitions[name] = parser.parse( ParserCore.ip_expression )

    method add_definitions( other:[String:Cmd] )
      definitions.add( other )

    method execute( cmd:Cmd )->Variant
      temporarily Program = this
        return cmd.execute
      endTemporarily

    method get_library( t:Token, library_name:String )->Library
      local mod = libraries[library_name]
      if (not mod)
        mod = Library( t, library_name )
        libraries[library_name] = mod
      endIf
      return mod

    method launch
      temporarily Program = this
        forEach (type in types)
          if (type.m_init_class)
            VM.stack.add( Variant() )
            Program.execute( type.m_init_class )
          endIf
        endForEach

        (forEach in libraries).launch
      endTemporarily

    method organize
      temporarily Program = this
        forEach (element in pending_elements)
          temporarily current_library = default_library
            CollectTypes.visit( element )
          endTemporarily
        endForEach
      endTemporarily

      temporarily Program=this, current_library=default_library
        forEach (entry in VM.native_types.entries)
          local type = Program.default_library.type( VM.t, entry.key, entry.value.attributes )
          if (entry.value.base_class_name)
            local base_class = Program.default_library.type( VM.t, entry.value.base_class_name )
            if (type.base_class and type.base_class is not base_class)
              throw CompileError( "Multiple base types defined for $: $ and $."...
                                  (type,type.base_class,base_class) )
            endIf
            type.base_class = base_class
          endIf
          type.attributes.is_native = true
          type.native_type = entry.value
          if (type.native_type.get_singleton or type.native_type.set_singleton)
            type.attributes.is_singleton = true
          endIf
          type.variant_type = entry.value.variant_type
        endForEach

        forEach (fn at type_name in VM.native_extended_types)
          VM.register_extensible_type( type_name, fn )
        endForEach

        forEach (entry in VM.native_definitions.entries)
          parser.reset( "[VM.register_definition($)]"(entry.key), entry.key )
          local type = parser.parse( ParserCore.ip_type )->(as Type).resolved
          parser._consume( TokenType.SYMBOL_PERIOD )
          local name = parser.parse( ParserCore.ip_identifier )
          parser = Parser( "[VM.register_definition($)]"(entry.key), entry.value )
          local value = parser.parse( ParserCore.ip_expression )
          type.definitions[name] = value
        endForEach

        forEach (entry in VM.native_constructors.entries)
          parser.reset( "[VM.register_constructor($)]"(entry.key), entry.key )
          local sig = parser.parse( ParserCore.ip_native_constructor_signature )->(as NativeConstructorSignature)
          local type = Program.default_library.must_find_type( sig.t, sig.scoped_type_name )
          local m = GlobalMethod( sig.t, "create" ).[ cmd_call=entry.value ]
          m.attributes.is_native_function = true
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = type
          m.statements.add( entry.value.cloned )
          type.add_global_method( m )
        endForEach

        forEach (entry in VM.native_global_method_definitions.entries)
          parser.reset( "[VM.register_global_method($)]"(entry.key), entry.key )
          local sig = parser.parse( ParserCore.ip_native_method_signature )->(as NativeMethodSignature)
          local type = Program.default_library.must_find_type( sig.t, sig.scoped_type_name )
          local m = GlobalMethod( sig.t, sig.qualified_name ).[ cmd_call=entry.value ]
          m.attributes.is_native_function = true
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = sig.return_type
          m.statements.add( entry.value.cloned )
          type.add_global_method( m )
        endForEach

        # Native methods
        forEach (entry in VM.native_method_definitions.entries)
          parser.reset( "[VM.register_method($)]"(entry.key), entry.key )
          local sig = parser.parse( ParserCore.ip_native_method_signature )->(as NativeMethodSignature)
          local type = Program.default_library.must_find_type( sig.t, sig.scoped_type_name )
          local m = Method( sig.t, sig.qualified_name ).[ cmd_call=entry.value ]
          m.attributes.is_native_function = true
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = sig.return_type
          m.statements.add( entry.value.cloned )
          type.add_method( m )
        endForEach

        # Native method default args
        block
          local previous_m : Method
          forEach (default_arg in VM.native_default_method_args)
            if local type = Program.default_library.find_type( default_arg.@type_name )
              if (default_arg.is_global)
                trace "TODO: global default arg"
              else
                if local m = type.methods[default_arg.signature]
                  if (m is not previous_m)
                    if (previous_m) previous_m.update_min_args
                    previous_m = m
                  endIf

                  assert default_arg.arg_index <= m.parameters.count
                  local param = m.parameters[default_arg.arg_index - 1]
                  parser.reset( "[Default arg $]"(param.name), default_arg.default_value )
                  param.initial_value = parser.parse( ParserCore.ip_expression )
                endIf
              endIf
            endIf
          endForEach
          if (previous_m) previous_m.update_min_args
        endBlock

        forEach (entry in VM.native_method_slots.entries)
          if local type = VM.find_type( entry.key )
            forEach (slot in entry.value)
              type.add_native_method_slot( slot.index, slot.signature )
            endForEach
          endIf
        endForEach

        forEach (elements in pending_elements)
          (forEach in elements.cloned).store
        endForEach

        (forEach in libraries).organize

        TypeResolver.resolve_types
        Organizer.organize_program

        pending_elements.clear

      endTemporarily

    method resolve
      temporarily Program = this
        Resolver.resolve_program
      endTemporarily

    method .configure
      Program = this
      t = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
      default_library = Library( t, "Rogue" )
      current_library = default_library

      type_Byte      = default_library.type( t, "Byte",      Attribute.PRIMITIVE )
      type_Character = default_library.type( t, "Character", Attribute.PRIMITIVE )
      type_Int       = default_library.type( t, "Int",       Attribute.PRIMITIVE )
      type_Int32     = default_library.type( t, "Int32",     Attribute.PRIMITIVE )
      type_Int64     = default_library.type( t, "Int64",     Attribute.PRIMITIVE )
      type_Logical   = default_library.type( t, "Logical",   Attribute.PRIMITIVE )
      type_Real      = default_library.type( t, "Real",      Attribute.PRIMITIVE )
      type_Real32    = default_library.type( t, "Real32",    Attribute.PRIMITIVE )
      type_Real64    = default_library.type( t, "Real64",    Attribute.PRIMITIVE )
      type_String    = default_library.type( t, "String",    Attribute.OBJECT )
      type_Object    = default_library.type( t, "Object",    Attribute.OBJECT )
      type_RogueScriptObject = default_library.type( t, "Object", Attribute.OBJECT )

      type_XY = default_library.type( t, "Geometry::XY", Attribute.COMPOUND )

endClass

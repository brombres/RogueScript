module RogueScript

$localMacro GENERAL_OP_RESOLVE<<$Cmd,$op,$allow_logical>>
augment Resolver
  METHODS
    method on_visit( cmd:$Cmd )->Cmd
      local left  = visit( cmd.left )
      local right = visit( cmd.right )
      local common_type = find_common_type( left, right, &promote_logical=not $allow_logical )

      left = convert_to( left, common_type )
      right = convert_to( right, common_type )

      if (common_type is Program.type_XY)
        return validate( $id($Cmd,XY)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Real64)
        return validate( $id($Cmd,Real64)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Real)
        return validate( $id($Cmd,Real)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Real32)
        return validate( $id($Cmd,Real32)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int64)
        return validate( $id($Cmd,Int64)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int)
        return validate( $id($Cmd,Int)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int32)
        return validate( $id($Cmd,Int32)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Character)
        return validate( $id($Cmd,Character)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Byte)
        return validate( $id($Cmd,Byte)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Logical)
        return validate( $id($Cmd,Logical)(cmd.t,left,right) )
      endIf

      throw cmd.t.error( $string("[INTERNAL] Unhandled operation: $ ",$op," $")(common_type,common_type) )
endAugment
$endLocalMacro

$localMacro GENERAL_OP_EXECUTE<<$Cmd,$op>>
augment
  METHODS
    method $id($Cmd,XY).type->Type:        return Program.type_XY
    method $id($Cmd,Real64).type->Type:    return Program.type_Real64
    method $id($Cmd,Real).type->Type:      return Program.type_Real
    method $id($Cmd,Real32).type->Type:    return Program.type_Real32
    method $id($Cmd,Int64).type->Type:     return Program.type_Int64
    method $id($Cmd,Int).type->Type:       return Program.type_Int
    method $id($Cmd,Int32).type->Type:     return Program.type_Int32
    method $id($Cmd,Character).type->Type: return Program.type_Character
    method $id($Cmd,Byte).type->Type:      return Program.type_Byte

    method $id($Cmd,Byte).execute->Variant:      return left.execute.xy $op right.execute.xy
    method $id($Cmd,Real64).execute->Variant:    return left.execute.real64 $op right.execute.real64
    method $id($Cmd,Real).execute->Variant:      return left.execute.real $op right.execute.real
    method $id($Cmd,Real32).execute->Variant:    return left.execute.real32 $op right.execute.real32
    method $id($Cmd,Int64).execute->Variant:     return left.execute.int64 $op right.execute.int64
    method $id($Cmd,Int).execute->Variant:       return left.execute.integer $op right.execute.integer
    method $id($Cmd,Int32).execute->Variant:     return left.execute.int32 $op right.execute.int32
    method $id($Cmd,Character).execute->Variant: return left.execute.character $op right.execute.character
    method $id($Cmd,Byte).execute->Variant:      return left.execute.byte $op right.execute.byte
endAugment
$endLocalMacro

$localMacro BITWISE_OP_RESOLVE<<$Cmd,$op>>
augment Resolver
  METHODS
    method on_visit( cmd:$Cmd )->Cmd
      local left  = visit( cmd.left )
      local right = visit( cmd.right )
      local common_type = find_common_type( left, right, &bitwise )

      left = convert_to( left, common_type )
      right = convert_to( right, common_type )

      if (common_type is Program.type_Int64)
        return validate( $id($Cmd,Int64)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int)
        return validate( $id($Cmd,Int)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int32)
        return validate( $id($Cmd,Int32)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Character)
        return validate( $id($Cmd,Character)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Byte)
        return validate( $id($Cmd,Byte)(cmd.t,left,right) )
      endIf

      throw cmd.t.error( $string("[INTERNAL] Unhandled operation: $ ",$op," $")(common_type,common_type) )
endAugment
$endLocalMacro

$localMacro BITWISE_OP_EXECUTE<<$Cmd,$op>>
augment
  METHODS
    method $id($Cmd,Int64).type->Type:     return Program.type_Int64
    method $id($Cmd,Int).type->Type:       return Program.type_Int
    method $id($Cmd,Int32).type->Type:     return Program.type_Int32
    method $id($Cmd,Character).type->Type: return Program.type_Character
    method $id($Cmd,Byte).type->Type:      return Program.type_Byte

    method $id($Cmd,Real64).execute->Variant:    return left.execute.real64 $op right.execute.real64
    method $id($Cmd,Real).execute->Variant:      return left.execute.real $op right.execute.real
    method $id($Cmd,Real32).execute->Variant:    return left.execute.real32 $op right.execute.real32
    method $id($Cmd,Int64).execute->Variant:     return left.execute.int64 $op right.execute.int64
    method $id($Cmd,Int).execute->Variant:       return left.execute.integer $op right.execute.integer
    method $id($Cmd,Int32).execute->Variant:     return left.execute.int32 $op right.execute.int32
    method $id($Cmd,Character).execute->Variant: return left.execute.character $op right.execute.character
    method $id($Cmd,Byte).execute->Variant:      return left.execute.byte $op right.execute.byte
endAugment
$endLocalMacro

$localMacro BINARY_OP_VALIDATE<<$Cmd,$op,$OpType,$ResultType>>
augment Resolver
  METHODS
    method on_validate( cmd:$id($Cmd,$OpType) )->Cmd
      if local left_literal = cmd.left->(as $id(Literal,$OpType))
        if local right_literal = cmd.right->(as $id(Literal,$OpType))
          return $id(Literal,$ResultType)( cmd.t, left_literal.value $op right_literal.value )
        endIf
      endIf
      return cmd
endAugment
$endLocalMacro

$localMacro MATH_OP<<$Cmd,$op>>
GENERAL_OP_RESOLVE<< $Cmd, $op, false >>
GENERAL_OP_EXECUTE<< $Cmd, $op >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real64,    Real64 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real,      Real   >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real32,    Real32 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int64,     Int64 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int,       Int   >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int32,     Int32 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Character, Character >>
BINARY_OP_VALIDATE<< $Cmd, $op, Byte,      Byte >>
$endLocalMacro

$localMacro LOGICAL_OP_EXECUTE<<$Cmd,$op,$OpType,$variant_property>>
augment $id($Cmd,$OpType)
  METHODS
    method execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      return Variant( left_value.$variant_property $op right_value.$variant_property )
endAugment
$endLocalMacro

$localMacro LOGICAL_OP<<$Cmd,$op>>

GENERAL_OP_RESOLVE<< $Cmd, $op, true >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real64,    Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real,      Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Real32,    Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int64,     Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int,       Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int32,     Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Character, Logical >>
BINARY_OP_VALIDATE<< $Cmd, $op, Byte,      Logical >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Real64,    logical >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Real,      real >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Real32,    real32 >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Int64,     int64 >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Int,       integer >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Int32,     int32 >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Character, character >>
LOGICAL_OP_EXECUTE<< $Cmd, $op, Byte,      byte >>
$endLocalMacro

$localMacro VALIDATE_CONVERT_OP<<$FromType,$ToType>>
augment Resolver
  METHODS
    method on_validate( cmd:$id(Convert,$FromType,To,$ToType) )->Cmd
      if local literal = cmd.operand->(as $id(Literal,$FromType))
        return $id(Literal,$ToType)( cmd.t, literal.value->$ToType )
      endIf
      return cmd
endAugment
$endLocalMacro

$localMacro BITWISE_OP<<$Cmd,$op>>
BITWISE_OP_RESOLVE<< $Cmd, $op >>
BITWISE_OP_EXECUTE<< $Cmd, $op >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int64,     Int64 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int,       Int   >>
BINARY_OP_VALIDATE<< $Cmd, $op, Int32,     Int32 >>
BINARY_OP_VALIDATE<< $Cmd, $op, Character, Character >>
BINARY_OP_VALIDATE<< $Cmd, $op, Byte,      Byte >>
$endLocalMacro

$localMacro OP_AND_ASSIGN_EXE<<$Cmd,$op,$OpType,$variant_property>>
augment
  METHODS
    method $id($Cmd,AndAssignGlobalProperty,$OpType).execute->Variant
      local operand = this.operand.execute
      local entry = info.type_context.global_property_values.find( info.name )
      entry.value.$variant_property $op operand.$variant_property
      return undefined

    method $id($Cmd,AndAssignLocal,$OpType).execute->Variant
      local operand = this.operand.execute
      local index = VM.fp + info.index
      local value = VM.stack[index]
      value $op operand.$variant_property
      VM.stack[index] = value
      return undefined

    method $id($Cmd,AndAssignProperty,$OpType).execute->Variant
      local operand = this.operand.execute
      if local context = this.context.execute.object->(as RogueScriptAdapted)
        local entry = context.rs_properties.find( info.name )
        entry.value.$variant_property $op operand.$variant_property
      else
        throw t.error( "Null context." )
      endIf
      return undefined

    method $id($Cmd,AndAssignThisProperty,$OpType).execute->Variant
      local operand = this.operand.execute
      local context = VM.context.object->(as RogueScriptAdapted)
      local entry = context.rs_properties.find( info.name )
      entry.value.$variant_property $op operand.$variant_property
      return undefined
endAugment
$endLocalMacro

$localMacro OP_AND_ASSIGN<<$Cmd,$op,$require_integers,$allow_logical>>
augment
  METHODS
    method Resolver.on_visit( cmd:$id($Cmd,AndAssign) )->Cmd
      return cmd.target.$id(resolve_,$lowercase($Cmd),_and_assign)( cmd.t, cmd.operand, this )

    method Resolver.on_visit( cmd:$id($Cmd,AndAssignGlobalProperty) )->Cmd
      cmd.operand = convert_to( visit(cmd.operand), cmd.info.type )
      which (cmd.info.type)
        case Program.type_Byte: return $id($Cmd,AndAssignGlobalPropertyByte)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Character: return $id($Cmd,AndAssignGlobalPropertyCharacter)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int: return $id($Cmd,AndAssignGlobalPropertyInt)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int32: return $id($Cmd,AndAssignGlobalPropertyInt32)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int64: return $id($Cmd,AndAssignGlobalPropertyInt64)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Logical
          if ($allow_logical)
            return $id($Cmd,AndAssignGlobalPropertyLogical)( cmd.t, cmd.info, cmd.operand )
          else
            throw cmd.t.error( "Illegal operation." )
          endIf
        others
          if ($require_integers)
            throw cmd.t.error( "Illegal operation." )
          else
            which (cmd.info.type)
              case Program.type_Real
                return $id($Cmd,AndAssignGlobalPropertyReal)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real32
                return $id($Cmd,AndAssignGlobalPropertyReal32)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real64
                return $id($Cmd,AndAssignGlobalPropertyReal64)( cmd.t, cmd.info, cmd.operand )
              case Program.type_XY
                return $id($Cmd,AndAssignGlobalPropertyXY)( cmd.t, cmd.info, cmd.operand )
            endWhich
          endIf
      endWhich
      return cmd

    method Resolver.on_visit( cmd:$id($Cmd,AndAssignLocal) )->Cmd
      cmd.operand = convert_to( visit(cmd.operand), cmd.info.type )
      which (cmd.info.type)
        case Program.type_Byte: return $id($Cmd,AndAssignLocalByte)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Character: return $id($Cmd,AndAssignLocalCharacter)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int: return $id($Cmd,AndAssignLocalInt)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int32: return $id($Cmd,AndAssignLocalInt32)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int64: return $id($Cmd,AndAssignLocalInt64)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Logical
          if ($allow_logical)
            return $id($Cmd,AndAssignLocalLogical)( cmd.t, cmd.info, cmd.operand )
          else
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          endIf
        others
          if ($require_integers)
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          else
            which (cmd.info.type)
              case Program.type_Real: return $id($Cmd,AndAssignLocalReal)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real32: return $id($Cmd,AndAssignLocalReal32)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real64: return $id($Cmd,AndAssignLocalReal64)( cmd.t, cmd.info, cmd.operand )
              case Program.type_XY:     return $id($Cmd,AndAssignLocalXY)( cmd.t, cmd.info, cmd.operand )
            endWhich
          endIf
      endWhich
      return cmd

    method Resolver.on_visit( cmd:$id($Cmd,AndAssignProperty) )->Cmd
      cmd.operand = convert_to( visit(cmd.operand), cmd.info.type )
      which (cmd.info.type)
        case Program.type_Byte
          return $id($Cmd,AndAssignPropertyByte)( cmd.t, cmd.context, cmd.info, cmd.operand )
        case Program.type_Character
          return $id($Cmd,AndAssignPropertyCharacter)( cmd.t, cmd.context, cmd.info, cmd.operand )
        case Program.type_Int
          return $id($Cmd,AndAssignPropertyInt)( cmd.t, cmd.context, cmd.info, cmd.operand )
        case Program.type_Int32
          return $id($Cmd,AndAssignPropertyInt32)( cmd.t, cmd.context, cmd.info, cmd.operand )
        case Program.type_Int64
          return $id($Cmd,AndAssignPropertyInt64)( cmd.t, cmd.context, cmd.info, cmd.operand )
        case Program.type_Logical
          if ($allow_logical)
            return $id($Cmd,AndAssignPropertyLogical)( cmd.t, cmd.context, cmd.info, cmd.operand )
          else
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          endIf
        others
          if ($require_integers)
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          else
            which (cmd.info.type)
              case Program.type_Real
                return $id($Cmd,AndAssignPropertyReal)( cmd.t, cmd.context, cmd.info, cmd.operand )
              case Program.type_Real32
                return $id($Cmd,AndAssignPropertyReal32)( cmd.t, cmd.context, cmd.info, cmd.operand )
              case Program.type_Real64
                return $id($Cmd,AndAssignPropertyReal64)( cmd.t, cmd.context, cmd.info, cmd.operand )
              case Program.type_XY
                return $id($Cmd,AndAssignPropertyXY)( cmd.t, cmd.context, cmd.info, cmd.operand )
            endWhich
          endIf
      endWhich
      return cmd

    method Resolver.on_visit( cmd:$id($Cmd,AndAssignThisProperty) )->Cmd
      cmd.operand = convert_to( visit(cmd.operand), cmd.info.type )
      which (cmd.info.type)
        case Program.type_Byte: return $id($Cmd,AndAssignThisPropertyByte)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Character: return $id($Cmd,AndAssignThisPropertyCharacter)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int: return $id($Cmd,AndAssignThisPropertyInt)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int32: return $id($Cmd,AndAssignThisPropertyInt32)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Int64: return $id($Cmd,AndAssignThisPropertyInt64)( cmd.t, cmd.info, cmd.operand )
        case Program.type_Logical
          if ($allow_logical)
            return $id($Cmd,AndAssignThisPropertyLogical)( cmd.t, cmd.info, cmd.operand )
          else
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          endIf
        others
          if ($require_integers)
            throw cmd.t.error( "Illegal operation - unsupported on type $."(cmd.info.type) )
          else
            which (cmd.info.type)
              case Program.type_Real
                return $id($Cmd,AndAssignThisPropertyReal)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real32
                return $id($Cmd,AndAssignThisPropertyReal32)( cmd.t, cmd.info, cmd.operand )
              case Program.type_Real64
                return $id($Cmd,AndAssignThisPropertyReal64)( cmd.t, cmd.info, cmd.operand )
            endWhich
          endIf
      endWhich
      return cmd

    method Cmd.$id(resolve_,$lowercase($Cmd),_and_assign)( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      throw this.t.error( "Invalid operation target." )

    method Access.$id(resolve_,$lowercase($Cmd),_and_assign)( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      if (args)
        throw this.t.error( "Invalid operation target." )
      endIf

      if local v = resolver.find_local( name )
        return resolver.visit( $id($Cmd,AndAssignLocal)(t, v, operand) )
      endIf

      if local p = resolver.this_type.properties[name]
        return resolver.visit( $id($Cmd,AndAssignThisProperty)(t, p, operand) )
      elseIf local p = resolver.this_type.global_properties[name]
        return resolver.visit( $id($Cmd,AndAssignGlobalProperty)(t, p, operand) )
      endIf

      throw this.t.error( "Invalid operation target." )

    method ContextAccess.$id(resolve_,$lowercase($Cmd),_and_assign)( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      context = resolver.visit( context )
      local context_type = context.require_type

      if local p = context_type.properties[name]
        if (context instanceOf This) return resolver.visit( $id($Cmd,AndAssignThisProperty)(t, p, operand) )
        else                         return resolver.visit( $id($Cmd,AndAssignProperty)(t, context, p, operand) )
      elseIf local p = context_type.global_properties[name]
        return resolver.visit( $id($Cmd,AndAssignGlobalProperty)(t, p, operand) )
      endIf

      throw this.t.error( ''No such property '$' exists in type '$'.''(name,context_type.name) )
endAugment
$endLocalMacro

$localMacro OP_AND_ASSIGN_GENERAL<<$Cmd,$op>>
OP_AND_ASSIGN<<$Cmd,$op,false,true>>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Byte,      byte >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Character, character >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int,       integer >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int32,     int32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int64,     int64 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Logical,   logical >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real,      real >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real32,    real32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real64,    real64 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, XY,        xy >>
$endLocalMacro

$localMacro OP_AND_ASSIGN_NUMERICAL<<$Cmd,$op>>
OP_AND_ASSIGN<<$Cmd,$op,false,false>>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Byte,      byte >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Character, character >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int,       integer >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int32,     int32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int64,     int64 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real,      real >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real32,    real32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Real64,    real64 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, XY,        xy >>
$endLocalMacro

$localMacro OP_AND_ASSIGN_BITWISE<<$Cmd,$op>>
OP_AND_ASSIGN<<$Cmd,$op,true,true>>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Byte,      byte >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Character, character >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int,       integer >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int32,     int32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int64,     int64 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Logical,   logical >>
$endLocalMacro

$localMacro OP_AND_ASSIGN_BIT_SHIFT<<$Cmd,$op>>
OP_AND_ASSIGN<<$Cmd,$op,true,false>>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Byte,      byte >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Character, character >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int,       integer >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int32,     int32 >>
OP_AND_ASSIGN_EXE<< $Cmd, $op, Int64,     int64 >>
$endLocalMacro

OP_AND_ASSIGN_GENERAL<<   Add,            += >>
OP_AND_ASSIGN_NUMERICAL<< Subtract,       -= >>
OP_AND_ASSIGN_GENERAL<<   Multiply,       *= >>
OP_AND_ASSIGN_NUMERICAL<< Divide,         /= >>
OP_AND_ASSIGN_NUMERICAL<< Mod,            %= >>
OP_AND_ASSIGN_NUMERICAL<< Power,          ^= >>
OP_AND_ASSIGN_BITWISE<<   BitwiseAnd,     &= >>
OP_AND_ASSIGN_BITWISE<<   BitwiseOr,      |= >>
OP_AND_ASSIGN_BITWISE<<   BitwiseXor,     ~= >>
OP_AND_ASSIGN_BIT_SHIFT<< BitShiftLeft,   :<<:=  >>
OP_AND_ASSIGN_BIT_SHIFT<< BitShiftRight,  :>>:=  >>
OP_AND_ASSIGN_BIT_SHIFT<< BitShiftRightX, :>>>:= >>

MATH_OP<< Add,      + >>
MATH_OP<< Subtract, - >>
MATH_OP<< Multiply, * >>
MATH_OP<< Divide,   / >>
MATH_OP<< Mod,      % >>
MATH_OP<< Power,    ^ >>

BITWISE_OP<< BitwiseAnd, & >>
BITWISE_OP<< BitwiseOr,  | >>
BITWISE_OP<< BitwiseXor, ~ >>
BITWISE_OP<< BitShiftLeft,   :<<: >>
BITWISE_OP<< BitShiftRight,  :>>: >>
BITWISE_OP<< BitShiftRightX, :>>>: >>

LOGICAL_OP<< CompareEQ, == >>
LOGICAL_OP<< CompareNE, != >>
LOGICAL_OP<< CompareLT, <  >>
LOGICAL_OP<< CompareLE, <= >>
LOGICAL_OP<< CompareGT, >  >>
LOGICAL_OP<< CompareGE, >= >>

VALIDATE_CONVERT_OP<<Real,Real64>>
VALIDATE_CONVERT_OP<<Real32,Real64>>
VALIDATE_CONVERT_OP<<Int64,Real64>>
VALIDATE_CONVERT_OP<<Int,Real64>>
VALIDATE_CONVERT_OP<<Int32,Real64>>
VALIDATE_CONVERT_OP<<Character,Real64>>
VALIDATE_CONVERT_OP<<Byte,Real64>>
VALIDATE_CONVERT_OP<<Logical,Real64>>
VALIDATE_CONVERT_OP<<Real64,Real>>
VALIDATE_CONVERT_OP<<Real32,Real>>
VALIDATE_CONVERT_OP<<Int64,Real>>
VALIDATE_CONVERT_OP<<Int,Real>>
VALIDATE_CONVERT_OP<<Int32,Real>>
VALIDATE_CONVERT_OP<<Character,Real>>
VALIDATE_CONVERT_OP<<Byte,Real>>
VALIDATE_CONVERT_OP<<Logical,Real>>
VALIDATE_CONVERT_OP<<Real64,Real32>>
VALIDATE_CONVERT_OP<<Real,Real32>>
VALIDATE_CONVERT_OP<<Int64,Real32>>
VALIDATE_CONVERT_OP<<Int,Real32>>
VALIDATE_CONVERT_OP<<Int32,Real32>>
VALIDATE_CONVERT_OP<<Character,Real32>>
VALIDATE_CONVERT_OP<<Byte,Real32>>
VALIDATE_CONVERT_OP<<Logical,Real32>>
VALIDATE_CONVERT_OP<<Real64,Int64>>
VALIDATE_CONVERT_OP<<Real,Int64>>
VALIDATE_CONVERT_OP<<Real32,Int64>>
VALIDATE_CONVERT_OP<<Int,Int64>>
VALIDATE_CONVERT_OP<<Int32,Int64>>
VALIDATE_CONVERT_OP<<Character,Int64>>
VALIDATE_CONVERT_OP<<Byte,Int64>>
VALIDATE_CONVERT_OP<<Logical,Int64>>
VALIDATE_CONVERT_OP<<Real64,Int>>
VALIDATE_CONVERT_OP<<Real,Int>>
VALIDATE_CONVERT_OP<<Real32,Int>>
VALIDATE_CONVERT_OP<<Int64,Int>>
VALIDATE_CONVERT_OP<<Int32,Int>>
VALIDATE_CONVERT_OP<<Character,Int>>
VALIDATE_CONVERT_OP<<Byte,Int>>
VALIDATE_CONVERT_OP<<Logical,Int>>
VALIDATE_CONVERT_OP<<Real64,Int32>>
VALIDATE_CONVERT_OP<<Real,Int32>>
VALIDATE_CONVERT_OP<<Real32,Int32>>
VALIDATE_CONVERT_OP<<Int64,Int32>>
VALIDATE_CONVERT_OP<<Int,Int32>>
VALIDATE_CONVERT_OP<<Character,Int32>>
VALIDATE_CONVERT_OP<<Byte,Int32>>
VALIDATE_CONVERT_OP<<Logical,Int32>>
VALIDATE_CONVERT_OP<<Real64,Character>>
VALIDATE_CONVERT_OP<<Real,Character>>
VALIDATE_CONVERT_OP<<Real32,Character>>
VALIDATE_CONVERT_OP<<Int64,Character>>
VALIDATE_CONVERT_OP<<Int,Character>>
VALIDATE_CONVERT_OP<<Int32,Character>>
VALIDATE_CONVERT_OP<<Byte,Character>>
VALIDATE_CONVERT_OP<<Logical,Character>>
VALIDATE_CONVERT_OP<<Real64,Byte>>
VALIDATE_CONVERT_OP<<Real,Byte>>
VALIDATE_CONVERT_OP<<Real32,Byte>>
VALIDATE_CONVERT_OP<<Int64,Byte>>
VALIDATE_CONVERT_OP<<Int,Byte>>
VALIDATE_CONVERT_OP<<Int32,Byte>>
VALIDATE_CONVERT_OP<<Character,Byte>>
VALIDATE_CONVERT_OP<<Logical,Byte>>
VALIDATE_CONVERT_OP<<Real64,Logical>>
VALIDATE_CONVERT_OP<<Real,Logical>>
VALIDATE_CONVERT_OP<<Real32,Logical>>
VALIDATE_CONVERT_OP<<Int64,Logical>>
VALIDATE_CONVERT_OP<<Int,Logical>>
VALIDATE_CONVERT_OP<<Int32,Logical>>
VALIDATE_CONVERT_OP<<Character,Logical>>
VALIDATE_CONVERT_OP<<Byte,Logical>>

augment
  METHODS
    method Resolver.on_validate( cmd:DivideInt )->Cmd
      if local right_literal = cmd.right->(as LiteralInt)
        if (right_literal.value == 0) throw cmd.t.error( "Integer division by 0." )
        if local left_literal = cmd.left->(as LiteralInt)
          return LiteralInt( cmd.t, left_literal.value / right_literal.value )
        endIf
      endIf
      return cmd

    method DivideInt.execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      if (right_value) return Variant( left_value.integer / right_value.integer )
      Global.error.println "[Integer division by 0]"
      return left_value

endAugment

class Resolver : Visitor [singleton]
  PROPERTIES
    scope_stack = ScopeStack()

  METHODS
    method resolve_program
      scope_stack.clear_stack
      visit_program( Program )

    method visit_module( mod:Module ) [override]
      temporarily Program.current_module = mod
        (forEach in mod.types).resolve
      endTemporarily

    method resolve_type( type:Type )
      use scope_stack
        temporarily Program.current_module = type.module_context
          visit_type( type )

          type.m_init_object = type.methods["init_object()"]
          type.m_init        = type.methods["init()"]
        endTemporarily
      endUse

    method resolve( procedure:Procedure )
      if (procedure.type_context is not this_type) return  # inherited method

      use scope_stack
        local type_context = procedure.type_context
        temporarily Program.current_module=type_context.module_context, this_type=type_context
          visit( procedure )
        endTemporarily
      endUse

    method add_local( t:Token, name:String, type:Type )->Local
      local v = Local( t, name, type )
      add_local( v )
      return v

    method add_local( identifier:Cmd, type:Type )->Local
      local v = Local( identifier.t, identifier->String, type )
      add_local( v )
      return v

    method add_local( v:Local )
      local existing_v = find_local( v.name )
      if (existing_v)
        if (v.index < this_procedure.param_count)
          throw v.t.error( ''A parameter named "$" already exists in the current scope.''(v.name) )
        else
          throw v.t.error( ''A local variable named "$" already exists in the current scope.''(v.name) )
        endIf
      endIf
      v.index = this_procedure.local_count
      ++this_procedure.local_count
      scope_stack.last.locals[v.name] = v

    method convert_to( cmd:Cmd, to_type:Type )->Cmd
      local cmd_type = cmd.require_type

      which (to_type)
        case cmd_type
          return cmd
        case Program.type_Real64
          which (cmd_type)
            case Program.type_Real:      return validate( ConvertRealToReal64(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToReal64(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToReal64(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToReal64(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToReal64(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToReal64(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToReal64(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToReal64(cmd.t,cmd) )
          endWhich
        case Program.type_Real
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToReal(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToReal(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToReal(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToReal(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToReal(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToReal(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToReal(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToReal(cmd.t,cmd) )
          endWhich
        case Program.type_Real32
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToReal32(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToReal32(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToReal32(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToReal32(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToReal32(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToReal32(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToReal32(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToReal32(cmd.t,cmd) )
          endWhich
        case Program.type_Int64
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToInt64(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToInt64(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToInt64(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToInt64(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToInt64(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToInt64(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToInt64(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToInt64(cmd.t,cmd) )
          endWhich
        case Program.type_Int
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToInt(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToInt(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToInt(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToInt(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToInt(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToInt(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToInt(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToInt(cmd.t,cmd) )
          endWhich
        case Program.type_Int32
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToInt32(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToInt32(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToInt32(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToInt32(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToInt32(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToInt32(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToInt32(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToInt32(cmd.t,cmd) )
          endWhich
        case Program.type_Character
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToCharacter(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToCharacter(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToCharacter(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToCharacter(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToCharacter(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToCharacter(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToCharacter(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToCharacter(cmd.t,cmd) )
          endWhich
        case Program.type_Byte
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToByte(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToByte(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToByte(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToByte(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToByte(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToByte(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToByte(cmd.t,cmd) )
            case Program.type_Logical:   return validate( ConvertLogicalToByte(cmd.t,cmd) )
          endWhich
        case Program.type_Logical
          which (cmd_type)
            case Program.type_Real64:    return validate( ConvertReal64ToLogical(cmd.t,cmd) )
            case Program.type_Real:      return validate( ConvertRealToLogical(cmd.t,cmd) )
            case Program.type_Real32:    return validate( ConvertReal32ToLogical(cmd.t,cmd) )
            case Program.type_Int64:     return validate( ConvertInt64ToLogical(cmd.t,cmd) )
            case Program.type_Int:       return validate( ConvertIntToLogical(cmd.t,cmd) )
            case Program.type_Int32:     return validate( ConvertInt32ToLogical(cmd.t,cmd) )
            case Program.type_Character: return validate( ConvertCharacterToLogical(cmd.t,cmd) )
            case Program.type_Byte:      return validate( ConvertByteToLogical(cmd.t,cmd) )
          endWhich
      endWhich

      throw cmd.t.error( "Cannot convert type $ to type $."(cmd_type,to_type) )

    method find_common_type( left:Cmd, right:Cmd, &bitwise, &promote_logical )->Type
      local left_type = left.require_type
      local right_type = right.require_type
      if (left_type is right_type)
        if ((bitwise or promote_logical) and left_type is Program.type_Logical) return Program.type_Int
        return left_type
      endIf

      if (left_type is Program.type_String or right_type is Program.type_String) return Program.type_String
      if (left_type is Program.type_XY or right_type is Program.type_XY) return Program.type_XY

      if (left_type.attributes.is_primitive and right_type.attributes.is_primitive)
        if (bitwise)
          if (left_type is Program.type_Real64 or right_type is Program.type_Real64) return Program.type_Int64
          if (left_type is Program.type_Real   or right_type is Program.type_Real)   return Program.type_Int
          if (left_type is Program.type_Real32 or right_type is Program.type_Real32) return Program.type_Int32
        else
          if (left_type is Program.type_Real64 or right_type is Program.type_Real64) return Program.type_Real64
          if (left_type is Program.type_Real   or right_type is Program.type_Real)   return Program.type_Real
          if (left_type is Program.type_Real32 or right_type is Program.type_Real32) return Program.type_Real32
        endIf
        if (left_type is Program.type_Int64  or right_type is Program.type_Int64)  return Program.type_Int64
        if (left_type is Program.type_Int    or right_type is Program.type_Int)    return Program.type_Int
        if (left_type is Program.type_Int32  or right_type is Program.type_Int32)  return Program.type_Int32
        if (left_type is Program.type_Character or right_type is Program.type_Character)
          return Program.type_Character
        endIf
        return Program.type_Byte  # must be a mix of Byte and Logical
      endIf

      throw left.t.error( "Types $ and $ are incompatible."(left_type,right_type) )

    method find_local( name:String )->Local
      forEach (scope in scope_stack step -1)
        if local v = scope.locals[name]
          return v
        endIf
      endForEach
      return null

    method on_visit( cmd:Access )->Cmd
      which (cmd.name)
        case "print":   return Print( cmd.t, visit(cmd.args)->(as Args) )
        case "println": return Println( cmd.t, visit(cmd.args)->(as Args) )
      endWhich

      if (not cmd.args)
        if local v = find_local( cmd.name )
          return visit( ReadLocal(cmd.t, v) )
        endIf

        if local p = this_type.properties[cmd.name]
          return visit( ReadThisProperty(cmd.t,p) )
        elseIf local p = this_type.global_properties[cmd.name]
          return visit( ReadGlobalProperty(cmd.t,p) )
        endIf
      endIf

      if local type = Program.current_module.find_type( cmd.name )
        if (cmd.args)
          return visit( Construct(cmd.t,type,cmd.args) )

        elseIf (type.attributes.is_singleton)
          if (type.native_type.get_singleton)
            return visit( ReadNativeSingleton(cmd.t,type) )
          else
            return visit( ReadSingleton(cmd.t,type) )
          endIf
        else
          return TypeContext( cmd.t, type )
        endIf
      endIf

      if local result = resolve_access( cmd.t, this_type, null, cmd.name, cmd.args, &suppress_error )
        return result
      else
        if local result = resolve_routine( cmd.t, this_type.module_context, cmd.name, cmd.args )
          return result
        endIf
        forEach (mod in this_type.module_context.used_modules)
          if local result = resolve_routine( cmd.t, mod, cmd.name, cmd.args )
            return result
          endIf
        endForEach
      endIf

      throw cmd.t.error( ''No such variable, method, or routine "$" exists in the current scope.''(cmd.name) )

    method resolve_routine( t:Token, mod:Module, name:String, args:Args )->Cmd
      return resolve_access( t, mod.type_Routine, null, name, args, &suppress_error )

    method on_visit( cmd:Assign )->Cmd
      return cmd.target.resolve_assignment( cmd.t, cmd.new_value, this )

    method on_validate( cmd:Binary )->Cmd
      #local left = cmd.left.require_value
      #local right = cmd.right.require_value
      cmd.left.require_type
      cmd.right.require_type
      return cmd

    method on_visit( cmd:Construct )->Cmd
      local type = cmd.@type
      if (type.native_type.create_object)
        return CreateNativeObject( cmd.t, type )
      else
        return resolve_access( cmd.t, cmd.@type, cmd, "init", cmd.args, &is_constructor )
      endIf

    method on_visit( cmd:ControlStructure )->Cmd
      scope_stack.add( cmd )
      visit( cmd.statements )
      scope_stack.remove_last
      return cmd

    method on_visit( cmd:ContextAccess )->Cmd
      return visit( cmd.context ).resolve_context_access( cmd, this )

    method on_visit( cmd:DefaultConstructor )->Cmd
      local t = cmd.t
      local type = cmd.of_type
      which (type.variant_type)
        case Variant.TYPE_OBJECT
          return visit( CreateDefaultObject(t,type) )
        case Variant.TYPE_STRING
          return visit( CreateDefaultString(t,type) )
        case Variant.TYPE_LIST
          return visit( CreateDefaultList(t,type) )
        case Variant.TYPE_TABLE
          return visit( CreateDefaultTable(t,type) )
        others
          return visit( CreateDefaultVariant(t,type) )
      endWhich

    method on_visit( cmd:ForEachIn )->Cmd
      cmd.collection = visit( cmd.collection )
      return cmd.collection.resolve_foreach_in( cmd, this )

    method on_visit( cmd:ForEachElementInRangeUpToInt )->Cmd
      scope_stack.add( cmd )
      visit( cmd.statements )
      scope_stack.remove_last
      return cmd

    method on_visit( cmd:If )->Cmd
      if (cmd.condition)
        cmd.condition = visit( cmd.condition ).require_value
        on_visit( cmd->(as ControlStructure) )
        cmd.cmd_else = visit( cmd.cmd_else )
        return validate( cmd )
      else
        return visit( Else(cmd.t,cmd.statements) )
      endIf

    method on_validate( cmd:If )->Cmd
      if (cmd.condition instanceOf Literal)
        if (cmd.condition->Logical)
          return cmd.statements
        else
          local cmd_else = cmd.cmd_else->(as Else)
          if (cmd_else) return cmd_else.statements
          else          return cmd_else
        endIf
      else
        return cmd
      endIf

    method on_validate( cmd:ConvertIntToReal )->Cmd
      if local literal_int = cmd.operand->(as LiteralInt)
        return LiteralReal( cmd.operand.t, literal_int.value )
      else
        return cmd
      endIf

    method on_visit( cmd:LocalDeclarations )->Cmd
      local initialization = Statements( cmd.t )

      forEach (v in cmd.list)
        v.initial_value = visit( v.initial_value )

        if (cmd.type)
          v.type = cmd.type
        elseIf (v.initial_value)
          v.type = v.initial_value.type
          if (not v.type)
            throw cmd.t.error( "Cannot implicitly determine type from initial value." )
          endIf
        else
          throw cmd.t.error( "Local variable declarations must have an initial value assignment or an assigned ': Type'." )
        endIf

        add_local( v )

        if (v.initial_value)
          initialization.add( WriteLocal(cmd.t,v,v.initial_value.require_value) )
        else
          initialization.add( SetLocalToDefaultValue(cmd.t,v) )
        endIf

      endForEach

      return initialization

    method on_validate( cmd:LogicalNot )->Cmd
      local operand = cmd.operand.require_value
      if local literal = operand->(as LiteralLogical)
        return LiteralLogical( literal.t, not literal.value )
      endIf
      return cmd

      #method on_visit( cmd:Loop )->Cmd

    method on_visit( proc:Procedure )->Cmd
      if (proc.type_context is not this_type) return proc  # inherited

      temporarily this_procedure = proc
        scope_stack.add( proc )

        proc.param_count = which{ proc.parameters:proc.parameters.count || 0 }
        ++proc.param_count  # 'this' for methods, null for global methods
        if (proc instanceOf Method)
          add_local( this_type.t, "this", this_type )
        else
          add_local( this_type.t, "null-context", this_type )
        endIf

        if (proc.parameters)
          forEach (param in proc.parameters)
            if (not param.type) throw param.t.error( "TODO: auto-store parameter" )
            param.type.resolve
            add_local( param.t, param.name, param.type )
          endForEach
        endIf

        if (proc.return_type) proc.return_type.resolve

        proc.local_count = 0
        visit_children( proc )
        scope_stack.remove_last
      endTemporarily
      return proc

    method on_validate( cmd:ReadProperty )->Cmd
      which (cmd.context.require_type.variant_type)
        case Variant.TYPE_OBJECT: return visit( ReadObjectProperty(cmd.t, cmd.context, cmd.info) )
        others: trace "TODO: Read property of non-object context"
      endWhich
      return cmd

    method on_visit( cmd:ReadThisProperty )->Cmd
      which (cmd.info.type.variant_type)
        case Variant.TYPE_OBJECT: return visit( ReadThisObjectProperty(cmd.t, cmd.info) )
        others: trace "TODO"
      endWhich
      return cmd

    method on_visit( cmd:Return )->Cmd
      if (cmd.result) return visit( ReturnResult(cmd.t,cmd.result) )
      else            return cmd

    method on_visit( cmd:This )->Cmd
      if (this_procedure.attributes.is_global)
        throw cmd.t.error( "Global methods and routines do not have a 'this' object context." )
      endIf
      cmd.type = this_type
      visit_children( cmd )
      return cmd

    method on_validate( cmd:Unary )->Cmd
      cmd.operand.require_type
      return cmd

    method on_visit( cmd:While )->Cmd
      scope_stack.add( cmd )

      visit_children( cmd )
      cmd.condition.require_value

      scope_stack.remove_last
      return cmd

    method on_validate( cmd:WriteGlobalProperty )->Cmd
      cmd.new_value.require_type
      return cmd

    method on_visit( cmd:WriteLocal )->Cmd
      local new_value = convert_to( visit(cmd.new_value), cmd.info.type )

      which (cmd.info.type)
        case Program.type_Int
          return WriteLocalInt( cmd.t, cmd.info, new_value )
        others
          trace cmd.info.type
          throw cmd.t.error( "[INTERNAL] Unhandled type in WriteLocal: $"(cmd.info.type) )
      endWhich

    method on_validate( cmd:WriteProperty )->Cmd
      cmd.new_value.require_type
      return cmd

    method on_validate( cmd:WriteThisProperty )->Cmd
      cmd.new_value.require_type
      return cmd

    method resolve_access( t:Token, type_context:Type, context:Cmd, name:String, args:Args,
        &is_constructor, &suppress_error )->Cmd
      if (args)
        visit( args )
        (forEach in args).require_value
      endIf

      if (name.contains("::"))
        local parts = name.split("::")
        local mod = Program.get_module( t, parts[0] )
        name = parts[1]
        if local type = mod.types[name]
          type_context = type
        elseIf local m = mod.type_Routine.global_methods_by_name[name]
          type_context = mod.type_Routine
        endIf
      endIf

      use CallCandidates
        if (is_constructor)
          type_context.collect_global_methods( "create" )
          type_context.collect_methods( "init" )
          if (CallCandidates.count == 0) return visit( DefaultConstructor(t,type_context) )
        elseIf (context and context instanceOf TypeContext)
          type_context.collect_global_methods( name )
        else
          type_context.collect_methods( name )
          type_context.collect_global_methods( name )
        endIf

        local m = select_call_candidate( t, type_context, context, name, args, &=is_constructor, &suppress_error )

        if (m)
          args = resolve_args( t, m, args )
          if (is_constructor)
            if (m.attributes.is_global)
              return visit( CallGlobalMethod(t, m, args) )
            else
              return visit( CreateObject(t, type_context, m, args) )
            endIf
          elseIf (m.attributes.is_global)
            return visit( CallGlobalMethod(t, m, args) )
          else
            if (not context or context instanceOf This)
              return visit( CallThisMethod(t, m, args) )
            else
              return visit( CallMethod(t, context, m, args) )
            endIf
          endIf
        endIf

        if (not args)
          # Check DEFINITIONS
          if local def = type_context.definitions[name]
            return visit( def.cloned )
          endIf

          # PROPERTIES
          if (context)
            if local p = type_context.properties[name]
              if (context instanceOf This) return visit( ReadThisProperty(t,p) )
              else                         return visit( ReadProperty(t,context,p) )
            endIf
          endIf

          # GLOBAL PROPERTIES
          if local p = type_context.global_properties[name]
            return visit( ReadGlobalProperty(t,p) )
          endIf

        endIf

        if (suppress_error) return null

        # throw error
        select_call_candidate( t, type_context, context, name, args, &=is_constructor )
      endUse

    method resolve_args( t:Token, m:Procedure, args:Args )->Args
      ensure<<args>>( t )
      while (args.count < m.max_args)
        local default_arg = m.parameters[args.count].initial_value
        assert default_arg
        args.add( visit(default_arg.cloned) )
      endWhile
      return args

    method select_call_candidate( t:Token, type_context:Type, context:Cmd, name:String, args:Args,
        &is_constructor, &suppress_error )->Procedure
      local m = select_call_candidate( name, args )
      if (m or suppress_error) return m

      # Construct and throw error message
      local call_sig = String()
      if (args)
        if (context)
          call_sig.print type_context
          call_sig.print '.'
        endIf
        call_sig.print name
        call_sig.print '('
        forEach (arg at i in args)
          if (i) call_sig.print( ',' )
          call_sig.print( arg.type )
        endForEach
        call_sig.print ')'
      else
        call_sig.print "'"
        if (context)
          call_sig.print type_context
          call_sig.print '.'
        endIf
        call_sig.print name
        call_sig.print "'"
      endIf

      local is_global = (context and context instanceOf TypeContext)
      if (CallCandidates.count)
        local message = String()
        message.println "No exact match for ambiguous call to $. Candidates:\n"(call_sig)
        forEach (m in CallCandidates)
          message.print "  "
          message.print m.type_context
          message.print '.'
          message.print m.signature
        endForEach
        throw t.error( message )
      else
        local possibilities = String[]
        if (args)
          possibilities.add( which{is_global:"global method" || "method"} )
        else
          if (context) possibilities.add( which{is_global:"global property" || "property"} )
          else         possibilities.add( "variable" )
          possibilities.add( "method" )
        endIf
        if (not context) possibilities.add( "routine" )
        if (is_constructor)
          throw t.error( "No such constructor $$ exists."(type_context,call_sig.from_first('(')) )
        elseIf (context)
          throw t.error( "No such $ $ exists."(possibilities.conjoin("or"),call_sig) )
        else
          throw t.error( "No such $ $ exists in the current scope."(possibilities.conjoin("or"),call_sig) )
        endIf
      endIf

    method select_call_candidate( name:String, args:Args )->Procedure
      local arg_count = which{ args:args.count || 0 }

      forEach (m in CallCandidates)
        if (arg_count >= m.min_args and arg_count <= m.max_args) CallCandidates.keep( m )
      endForEach

      if (CallCandidates.found_match)
        return CallCandidates.match
      endIf
      CallCandidates.refine

      return null

endClass

augment
  METHODS
    method Cmd.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      throw this.t.error( "Invalid assignment." )

    method Access.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      if local v = resolver.find_local( name )
        return resolver.visit( WriteLocal(t,v,new_value) )
      endIf

      if local p = resolver.this_type.properties[name]
        return resolver.visit( WriteThisProperty(t, p, new_value) )
      elseIf local p = resolver.this_type.global_properties[name]
        return resolver.visit( WriteGlobalProperty(t, p, new_value) )
      endIf

      throw this.t.error( ''No such variable, method, or routine "$" exists in the current scope.''(name) )

    method ContextAccess.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      context = resolver.visit( context )
      local context_type = context.require_type

      if local p = context_type.properties[name]
        if (context instanceOf This) return resolver.visit( WriteThisProperty(t, p, new_value) )
        else                         return resolver.visit( WriteProperty(t, context, p, new_value) )
      elseIf local p = context_type.global_properties[name]
        return resolver.visit( WriteGlobalProperty(t, p, new_value) )
      endIf

      throw this.t.error( ''No such property '$' exists in type '$'.''(name,context_type.name) )

    method Cmd.resolve_context_access( access:ContextAccess, resolver:Resolver )->Cmd
      local resolved = resolver.visit( this )
      local resolved_type = resolved.require_type
      return resolver.resolve_access( access.t, resolved_type, resolved, access.name, access.args )

    method TypeContext.resolve_context_access( access:ContextAccess, resolver:Resolver )->Cmd
      return resolver.resolve_access( access.t, require_type, this, access.name, access.args )

    method Cmd.resolve_foreach_in( cmd_foreach_in:ForEachIn, resolver:Resolver )->Cmd
      throw t.error( "TODO: resolve_foreach_in($)"(type_name) )

    method CreateRangeUpTo.resolve_foreach_in( cmd_foreach_in:ForEachIn, resolver:Resolver )->Cmd
      local type = resolver.find_common_type( start, limit )
      if (step_size) type = resolver.find_common_type( type, step_size )

      local v = Local( cmd_foreach_in.element_name.t, cmd_foreach_in.element_name->String, type )

      if (step_size)
        throw t.error( "TODO: resolve_foreach_in($) with step size"(type_name) )
      endIf

      local result = ForEachElementInRangeUpToInt( cmd_foreach_in.t, v, start, limit, cmd_foreach_in.statements )
      result.add_local( v, resolver.this_procedure )
      return resolver.visit( result )

endAugment

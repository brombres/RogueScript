library RogueScript

class Type : Cmd
  PROPERTIES
    batch_id             : Int

    module_context       : Library
    definition           : Class

    attributes           : Attributes
    base_class           : Type
    aspects              : Type[]

    name                 : String
    scoped_name          : String
    element_type         : Type
    is_optional_type     : Logical
    variant_type         = Variant.TYPE_OBJECT : Int

    native_type             : NativeTypeInfo
    global_methods          = [String:GlobalMethod]
    global_methods_by_name  = [String:GlobalMethod[]]
    methods                 = [String:Method]
    methods_by_name         = [String:Method[]]
    definitions             = [String:Cmd]
    global_properties       = [String:Property]
    global_property_values  = [String:Variant]
    properties              = [String:Property]
    vtable                  = Method[]
    native_global_methods   : GlobalMethod[]
    native_method_overrides : Method[]

    visiting               : Logical
    is_resolved            : Logical
    properties_inherited   : Logical
    methods_inherited      : Logical
    native_info_propagated : Logical

    singleton_value : Variant
    m_init_class    : GlobalMethod
    m_init_object   : Procedure
    m_init          : Procedure

  METHODS
    method init( t, name )

    method init( t, element_type )

    method init( t, element_type, is_optional_type )

    method init( t, module_context, name, attributes )
      if (not attributes.classification) attributes.is_object = true

    method init( existing:Type )
      prior.init( existing )
      name = existing.name
      if (existing.element_type) element_type = existing.element_type.cloned
      is_optional_type = existing.is_optional_type

    method init_object
      batch_id = Parser.current_batch_id

    method add( m:GlobalMethod )
      println StackTrace()
      add_global_method( m )

    method add( m:Method )
      println StackTrace()
      add_method( m )

    method add_global_method( m:GlobalMethod )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context and not existing_m.attributes.is_native)
          if (m.attributes.is_native) return
          local m_type = which{ name=="Routine":"routine " || "global method $."(this) }
          throw m.t.error( "A $$ already exists."(m_type,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context)
          throw m.t.error( "A method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      if (m.name == "create")
        if (not m.return_type or m.return_type is not this)
          throw m.t.error( "A $ create() constructor must have return type $."(this,this) )
        endIf
      elseIf (m.name == "init")
        throw m.t.error( "A $ init() constructor cannot be a global method."(this) )
      endIf

      global_methods[m.signature] = m
      if (not global_methods_by_name.contains(m.name))
        global_methods_by_name[m.name] = GlobalMethod[]
      endIf
      global_methods_by_name[m.name].add( m )

    method add_method( m:Method )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m)
          throw m.t.error( "A global method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m)
          if (existing_m.type_context is m.type_context)
            if (not existing_m.attributes.is_native)
              if (m.attributes.is_native) return
              throw m.t.error( "A method $.$ already exists."(this,m.signature) )
            endIf
            m.overridden_m = existing_m
          else
            existing_m.overridden_m = m
            return # do not replace overridden method (existing_m) with base method (m)
          endIf
        endIf
      endBlock

      if (m.name == "init")
        if (m.return_type)
          throw m.t.error( "A $ init() constructor cannot have a return type."(this) )
        endIf
      elseIf (m.name == "create")
        throw m.t.error( "A $ create() constructor must be a global method."(this) )
      endIf

      methods[m.signature] = m

      local group = methods_by_name[m.name]
      if (not group)
        group = Method[]
        methods_by_name[m.name] = group
      endIf
      if (not group.contains( $.signature == m.signature ))
        group.add( m )
      endIf

    method add_global_property( p:Property )
      p.type_context = this
      if (global_properties.contains(p.name))
        throw p.t.error( "A global property named '$' already exists."(p.name) )
      endIf
      global_properties[p.name] = p

    method add_property( p:Property )
      p.type_context = this
      if (properties.contains(p.name))
        throw p.t.error( "A property named '$' already exists."(p.name) )
      endIf
      properties[p.name] = p

    method add_native_method_slot( index:Int, signature:String )
      ensure<<native_method_overrides>>
      native_method_overrides.expand_to_include( index )
      native_method_overrides[index] = methods[signature]

    method collect_base_types
      if (definition)
        forEach (base_type in definition.base_types)
          base_type = module_context.must_find_type( base_type )
          if (base_type.attributes.is_aspect)
            ensure<<aspects>>
            aspects.add( base_type )
          elseIf (base_type.attributes.is_object == this.attributes.is_object)
            base_class = base_type
          else
            throw t.error( "[INTERNAL] Unhandled type attributes for base type " + base_type )
          endIf
        endForEach
      endIf

      if (not base_class and attributes.is_object and this is not Program.type_Object)
        base_class = Program.type_RogueScriptObject
      endIf

    method collect_global_methods( method_name:String )
      local methods = global_methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method collect_methods( method_name:String )
      local methods = methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method create_class_initializer
      if (global_properties.count)
        m_init_class = GlobalMethod( t, "init_class" )
        forEach (p in global_properties)
          local cmd_initial_value : Cmd
          if (p.initial_value) cmd_initial_value = p.initial_value.cloned
          else cmd_initial_value = CreateDefaultVariant( t, p.type  )
          m_init_class.statements.add( WriteGlobalProperty(t, p, cmd_initial_value) )
        endForEach
        add_global_method( m_init_class )
      endIf

    method create_init_object_methods
      if (properties.count)
        local m = Method( t, "init_object" )
        add_method( m )
        forEach (p in properties)
          if (p.initial_value)
            m.statements.add( Assign(p.t, Access(p.t,p.name), p.initial_value) )
          else
            local value : Variant
            local type = p.type.variant_type
            which (type)
              case Variant.TYPE_UNDEFINED: value = Variant()
              case Variant.TYPE_BYTE:      value = Byte(0)
              case Variant.TYPE_CHARACTER: value = '\0'
              case Variant.TYPE_INT32:     value = 0i
              case Variant.TYPE_COLOR:     value = Graphics::Color(0)
              case Variant.TYPE_INT:       value = 0
              case Variant.TYPE_INT64:     value = 0I
              case Variant.TYPE_REAL32:    value = 0r
              case Variant.TYPE_REAL:      value = 0
              case Variant.TYPE_REAL64:    value = 0R
              case Variant.TYPE_DEGREES:   value = Degrees(0)
              case Variant.TYPE_RADIANS:   value = Radians(0)
              case Variant.TYPE_LOGICAL:   value = false
              case Variant.TYPE_NULL:      value = null
              case Variant.TYPE_ANCHOR:    value = Anchor(XY(0,0))
              case Variant.TYPE_XY:        value = XY(0,0)
              case Variant.TYPE_XYZ:       value = XYZ(0,0,0)
              case Variant.TYPE_XYZW:      value = XYZW(0,0,0,0)
              case Variant.TYPE_LINE:      value = Line(XY(0),XY(0))
              case Variant.TYPE_CIRCLE:    value = Circle(XY(0),0)
              case Variant.TYPE_TRIANGLE:  value = Triangle(XY(0),XY(0),XY(0))
              case Variant.TYPE_BOX:       value = Box(0,0,0,0)
              case Variant.TYPE_QUAD32:    value = Quad(XY(0),XY(0),XY(0),XY(0))
              others
                if (type >= Variant.TYPE_OBJECT)
                  value = null
                else
                  throw p.t.error(
                    "[INTERNAL] Unhandled variant type $ in Type.create_init_object_methods()."(type)
                  )
                endIf
            endWhich
            m.statements.add( WriteThisPropertyValue(p.t,p,value) )
          endIf
        endForEach
      endIf

    method description->String
      return name

    method inherit_properties
      if (properties_inherited) return
      properties_inherited = true

      if (base_class) inherit_properties( base_class )
      if (aspects)
        forEach (a in aspects)
          inherit_properties( a )
        endForEach
      endIf

    method inherit_properties( of_type:Type )
      of_type.inherit_properties

      forEach (base_p in of_type.global_properties)
        local this_p = global_properties[base_p.name]
        if (this_p)
          throw this_p.t.error( "Global property '$' already exists in a base type and cannot be redefined." (base_p.name) )
        else
          global_properties[base_p.name] = base_p
        endIf
      endForEach

      forEach (base_p in of_type.properties)
        local this_p = properties[base_p.name]
        if (this_p)
          if (this_p.type)
            if (this_p.type is not base_p.type)
              throw this_p.t.error( "Inherited property '$' redefined with different type."(base_p.name) )
            endIf
          else
            this_p.type = base_p.type
          endIf
        else
          properties[base_p.name] = base_p
        endIf
      endForEach

    method inherit_methods
      if (methods_inherited) return
      methods_inherited = true

      if (base_class)
        inherit_methods( base_class )

        # Inherit native method overrides
        if (base_class.native_method_overrides)
          ensure<<native_method_overrides>>
          native_method_overrides.expand_to_count( base_class.native_method_overrides.count )
          forEach (m at i in base_class.native_method_overrides)
            if (m and not native_method_overrides[i])
              local m2 = methods[m.signature]
              native_method_overrides[i] = m2 || m
            endIf
          endForEach
        endIf
      endIf

      if (aspects)
        forEach (a in aspects)
          inherit_methods( a )
        endForEach
      endIf

      # Add inherited and overridden methods to vtable
      forEach (m in methods)
        if (m.overridden_m) m.vtable_index = m.overridden_m.vtable_index
        if (m.vtable_index != -1)
          vtable.expand_to_include( m.vtable_index )
          vtable[m.vtable_index] = m
        endIf
      endForEach

      # Add new methods to vtable
      forEach (m in methods)
        if (m.vtable_index == -1)
          m.vtable_index = vtable.count
          vtable.add( m )
        endIf
      endForEach

      #println "$$"(scoped_name,which{base_class?.scoped_name:" : " + base_class.scoped_name || ""})
      #forEach (m at i in vtable)
      #  println "$ $"(i,m)
      #endForEach
      #println

    method inherit_methods( of_type:Type )
      of_type.inherit_methods

      if (not native_type.create_extended_object)
        native_type.create_extended_object = of_type.native_type.create_extended_object
      endIf

      add_method( forEach in of_type.methods )

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true
      if (base_class and base_class.instance_of(ancestor_type)) return true
      if (aspects)
        forEach (a in aspects)
          if (a.instance_of(ancestor_type)) return true
        endForEach
      endIf
      return false

    method propagate_constructor_info
      if (native_info_propagated) return
      native_info_propagated = true

      ensure<<native_type>>
      if (base_class)
        base_class.propagate_constructor_info
        if (not native_type.create_extended_object)
          native_type.create_extended_object = base_class.native_type.create_extended_object
        endIf
      endIf

    method resolve
      if (is_resolved) return
      is_resolved = true
      Resolver.resolve_type( this )

    method resolved->Type
      local mod = module_context
      if (not mod) mod = Program.default_library
      local result = mod.must_find_type( this )
      return result

    method scoped_name->String
      if (@scoped_name) return @scoped_name
      if (not module_context) return "<undefined>::$"(name)
      @scoped_name = "$::$"(module_context,name)
      return @scoped_name

    method to->String
      return name

    method validate_properties
      forEach (p in global_properties)
        if (not p.type)
          if (p.initial_value)
            p.type = p.initial_value.type
            if (not p.type)
              throw p.t.error( "Unable to infer type of global property '$' from initial value."...
                " Add ': TypeName' to explicitly declare type." (p.name) )
            endIf
          else
            throw p.t.error(
              "Cannot determine type of global property '$' - add '= initial_value' or ': TypeName'."(p.name)
            )
          endIf
        endIf
      endForEach

      forEach (p in properties)
        if (not p.type)
          if (p.initial_value)
            p.type = p.initial_value.type
            if (not p.type)
              throw p.t.error( "Unable to infer type of property '$' from initial value."...
                " Add ': TypeName' to explicitly declare type." (p.name) )
            endIf
          else
            throw p.t.error(
              "Cannot determine type of property '$' - add '= initial_value' or ': TypeName'."(p.name)
            )
          endIf
        endIf
      endForEach

    method validate_type_hierarchy
      validate_type_hierarchy( this )

    method validate_type_hierarchy( extended_type:Type )
      contingent
        visiting = true
        if (base_class)
          sufficient (base_class is this)
          necessary (not base_class.visiting)
          base_class.validate_type_hierarchy( extended_type )
        endIf
        if (aspects)
          forEach (a in aspects)
            sufficient (a is this)
            necessary (not a.visiting)
            a.validate_type_hierarchy( extended_type )
          endForEach
        endIf
        visiting = false
        return

      satisfied
        throw t.error( "Circular class extension - class $ cannot extend itself."(name) )

      unsatisfied
        local a_name = extended_type.name
        local b_name = name
        if (module_context is not extended_type.module_context)
          a_name = extended_type.scoped_name
          b_name = scoped_name
        endIf
        throw t.error( "Circular class extension - class $ already extends $."(a_name,b_name) )

      endContingent

endClass


module RogueScript

class VM [singleton]
  PROPERTIES
    t                 = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
    new_elements      : [String:ProgramElements]
    resolved_elements : [String:ProgramElements]
    include_folders   = Set<<String>>().[ add("") ]

    native_types            = [String:NativeTypeInfo]
    native_constructors     = [String:Cmd]
    native_global_method_definitions = [String:Cmd]
    native_method_definitions        = [String:Cmd]
    native_definitions         = [String:String]
    native_extended_types      = [String:Function(Type)->Variant]
    definitions                = [String:Cmd]
    native_method_slots        = [String:NativeMethodSlot[]]
    native_default_method_args = NativeDefaultArg[]

    program : Program
    stack   = Variant[]
    fp      : Int

    resolve_filepath = (filepath) => filepath : Function(String)->String

  METHODS # External runtime API
    method init
      register_native_type( <<Rogue::Object>> )

    method compile( script:String )->(Function->Variant)
      launch

      temporarily VM=this, Program=program
        local statements = Parser( "[EXECUTE]", script ).parse( Parser.ip_multi_line_statements )->(as Statements)
        local m_execute = GlobalMethod( statements.t, "execute", &statements=statements )
        m_execute.type_context = Program.default_module.type( Program.default_module.t, "Routine" )
        Resolver.resolve( m_execute )
        return function()->Variant with (vm=this)
          temporarily VM=vm, Program=program
            return program.execute( m_execute )
          endTemporarily
        endFunction
      endTemporarily

    method execute( script:String )->Variant
      return compile(script)()

  METHODS # Internal runtime API
    method context->Variant
      return stack[fp]

    method context_object->Rogue::Object
      if local obj = stack[fp].object
        return obj
      else
        throw RogueScriptNullReferenceError
      endIf

    method int( index:Int )->Int
      return stack[fp+index]->Int

    method logical( index:Int )->Int
      return stack[fp+index]?

    method call_method( context:Variant, m:Procedure, args=null:Args )->Variant
      local old_stack_count = stack.count
      stack.add( context )

      if (args and args.count) stack.add( (forEach in args).execute )

      local result = m.execute
      stack.discard_from( old_stack_count )
      return result

      #{
    method configure_native_method_override( rs_type:Type, index:Int, signature:String )
      #if local rs_type =
      if local base_type_info = obj.type_info.base_class
        if local rs_m = rs_type.methods[signature]
          if (not rs_m.attributes.is_native_function)
            rs_type.native_method_definitions.[expand_to_include(index)][index] = rs_m
          endIf
        endIf
      endIf
      }#

    method create_object( of_type:Type, &no_init )->Variant
      local obj : Variant
      if local create_fn = of_type.native_type.create_extended_object
        obj = create_fn( of_type )
        #{
        if (not of_type.native_method_overrides)
          ensure<<of_type.native_method_overrides>>
          local type_info = obj->Object?.type_info
          assert type_info
          assert type_info.base_class
          of_type.native_method_overrides.expand_to_count( type_info.base_class.methods.count )
          obj.to<<RogueScript::RogueScriptAdapted>>._configure_native_overrides
        endIf
        }#
      else
        obj = RogueScriptObject( of_type )
      endIf
      if (of_type.m_init_object) call_method( obj, of_type.m_init_object )
      if (not no_init and of_type.m_init) call_method( obj, of_type.m_init )
      return obj

    method create_object( of_type:Type, m_init:Procedure, args:Args )->Variant
      local obj = Variant( RogueScriptObject(of_type) )
      call_method( obj, m_init, args )
      return obj

    method find_global_method( scoped_signature:String )->GlobalMethod
      local type = Program.default_module.find_type( scoped_signature.before_first('.') )
      if (not type) return null
      return type.global_methods[ scoped_signature.after_first('.') ]

    method find_method( scoped_signature:String )->Method
      local type = Program.default_module.find_type( scoped_signature.before_first('.') )
      if (not type) return null
      return type.methods[ scoped_signature.after_first('.') ]

    method find_type( name:String )->Type
      return Program.default_module.find_type( name )

    method parameter( index:Int )->Variant
      # First parameter is index 1.
      return stack[fp+index]

    method real( index:Int )->Real
      return stack[fp+index]->Real

    method string( index:Int )->String
      return stack[fp+index]->String

    method xy( index:Int )->XY
      return stack[fp+index]->XY

  METHODS # Configuration
    method deregister_constructor( signature:String )
      if (native_constructors.remove(signature)) .begin_staging

    method deregister_global_method( full_signature:String )
      if (native_global_method_definitions.remove(full_signature)) .begin_staging

    method deregister_method( full_signature:String )
      if (native_method_definitions.remove(full_signature)) .begin_staging

    method deregister_type( scoped_name:String )
      if (native_types.remove(scoped_name)) .begin_staging

    method include( file:File, &suppress_error )->Logical
      # Loads file if not already loaded.
      if local found_file = .find_file( file )
        local filepath = found_file.filepath
        if (new_elements and new_elements.contains(filepath)) return true
        return load( found_file, &=suppress_error )
      else
        if (suppress_error) return false
        throw CompileError( "File not found: $"(file) )
      endIf

    method launch
      try
        temporarily VM = this
          register_native_methods
          if (new_elements and new_elements.count)
            local staged_program = Program( new_elements.values )
            resolved_elements = new_elements
            new_elements = null
            staged_program.organize
            staged_program.resolve
            staged_program.launch
            program = staged_program
          elseIf (not program)
            program = Program()
            program.organize
            program.resolve
            program.launch
          endIf
        endTemporarily
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method load( file:File, &suppress_error )->Logical
      if local found_file = .find_file( file )
        file = found_file
      else
        if (suppress_error) return false
        throw RogueScriptError( "File not found: " + file )
      endIf

      return load( file, String(file), &=suppress_error )

    method load( file:File, source:String, &suppress_error )->Logical
      .begin_staging

      try
        temporarily VM = this
          local elements = Parser( file, source ).parse->(as ProgramElements)
          new_elements[file.filepath] = elements
          (forEach in elements).preprocess
        endTemporarily

      catch (error:Exception)
        new_elements = null
        if (suppress_error) return false
        throw error

      endTry

      return true

    method register_constructor( signature:String, cmd:Cmd )
      native_constructors[signature] = cmd
      .begin_staging

    method register_constructor( full_signature:String, callback:Function()->Variant )
      register_constructor( full_signature, CallNativeMethod(t,callback) )

    method register_definition( scoped_name:String, value:String )
      # E.g. register_definition( "Int.BITS", "64" )
      # E.g. register_definition( "Rogue::Int.BITS", "64" )
      native_definitions[scoped_name] = value

    method register_global_method( full_signature:String, cmd:Cmd )
      native_global_method_definitions[full_signature] = cmd
      .begin_staging

    method register_global_method( full_signature:String, callback:Function()->Variant )
      register_global_method( full_signature, CallNativeMethod(t,callback) )

    method register_native_method_default_arg( type_name:String, signature:String, arg_index:Int, default_value:String )
      native_default_method_args.add( NativeDefaultArg(type_name, signature, arg_index, default_value) )

    method register_native_methods
      forEach (info in native_types)
        if (not info.methods_registered)
          info.methods_registered = true
          if (info.info)
            forEach (m in info.info.methods)
              .register_native_method( m )
            endForEach
          endIf
        endIf
      endForEach

    method .register_native_method( m:MethodInfo )
      contingent # FIXME - improve
        if (m.parameters.count)
          forEach (param in m.parameters)
            necessary (native_types.contains(param.type.scoped_name))
          endForEach
        endIf
        sufficient (not m.return_type)
        sufficient (m.return_type.is_primitive)
        sufficient (m.return_type.scoped_name == "Rogue::String")
        necessary (false)
      unsatisfied
        return
      endContingent
      local sig = "$.$"(m.type_context.scoped_name,m.signature)
      if (m.return_type) sig = "$->$"(sig,m.return_type.scoped_name)
      register_method( sig, () => m.rs_call_method )


    method register_native_type( type:TypeInfo, info=null:NativeTypeInfo )
      ensure<<info>>()
      info.info = type
      if (not info.create_object) info.create_object = () => type.create_object
      if (not info.instance_of)   info.instance_of = (v) => v? and v->Object.type_info.instance_of(type)
      if (type.is_singleton)
        if (not info.get_singleton) info.get_singleton = () => type.singleton
        if (not info.set_singleton) info.set_singleton = (new_value) => type.singleton = new_value
      endIf
      if (not info.base_class_name)
        if local base_class = type.base_class
          info.base_class_name = base_class.scoped_name
        endIf
      endIf
      register_type( type.scoped_name, info )

    method register_method( full_signature:String, cmd:Cmd )
      native_method_definitions[full_signature] = cmd
      .begin_staging

    method register_method( full_signature:String, callback:Function()->Variant )
      register_method( full_signature, CallNativeMethod(t,callback) )

    method register_native_method_slot( type_name:String, index:Int, signature:String )
      local list = native_method_slots[type_name]
      if (not list)
        list = NativeMethodSlot[]
        native_method_slots[type_name] = list
      endIf
      list.add( NativeMethodSlot(index, signature) )

    method register_extensible_type( native_type:String, create_extended_object:Function(Type)->Variant )
      if local entry = native_types.find( native_type )
        entry.value.create_extended_object = create_extended_object
      else
        native_extended_types[native_type] = create_extended_object
      endIf

    method register_type( scoped_name:String, info=NativeTypeInfo():NativeTypeInfo )
      native_types[scoped_name] = info

    method unload( file:File )
      .begin_staging

      local filepath = file.abs.filepath
      new_elements.remove( filepath )
      resolved_elements?.remove( filepath )

    method update
      try
        launch
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method .begin_staging
      if (not new_elements)
        if (resolved_elements)
          new_elements = resolved_elements.cloned
        else
          new_elements = [String:ProgramElements]
        endIf
      endIf

    method .find_file( file:File )->File?
      local found_file = File( resolve_filepath(file) )
      contingent
        sufficient (found_file.exists)

        forEach (folder in include_folders)
          found_file = File( resolve_filepath(folder / file) )
          if (not found_file.exists)
            found_file = File( resolve_filepath(found_file.with_extension(".rogue")) )
          endIf
          sufficient (found_file.exists)
        endForEach

        return null

      satisfied
        file = found_file
      endContingent

      if (file.is_folder)
        found_file = (file / file.filename) + ".rogue"
        if (not found_file.exists) return null
        file = found_file
      endIf

      file .= abs

      local folder = file.abs.folder
      include_folders[folder] = folder

      return file

endClass
